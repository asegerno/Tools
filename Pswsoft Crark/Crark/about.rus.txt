Новые    версии    этой    программы   находятся    по   адресу:
http://www.crark.net/.

-----------------------------------------------------------------
Изменения в версиях:

5.5b
    - поддержка расширений SHA в процессорах Intel/AMD Ryzen,
до 4 раз быстрее. Впервые пароли RAR 5.0 тестируются быстрее, чем
RAR 3.0

5.5 - PDL 4.0 c поддержкой Unicode в паролях и словарях
    - регулярный символ '*' теперь может быть не только в конце
и ему можно явно задавать длину
    - другие улучшения языка описания паролей, включая генераторы

5.2b - поддержка NVIDIA Volta и AMD RX Vega, на RX Vega повышена
скорость на 50% при тестировании RAR 3.0
     - быстрее на 2-5% архивы RAR 5.0 на многих GPU
     - файлы нулевой длины теперь пропускаются

5.2a - исправлена серьезная ошибка co stored-файлами (пароль не
находился)

5.2 - скорость rar 3.0 стала выше до 30% на NVIDIA 9xx/1xxx
    - CUDA-версия больше не обновляется, т.к. ее скорость не лучше, чем
в OpenCL

5.1 - 64-битная версия, 32-битная больше не обновляется. Выигрыш
по скорости около 5-20% на разных типах архивов
    - карты NVIDIA G80 (compute capability 1.x) больше не
поддерживаются
    - Intel GPU не поддерживается до тех пор, пока драйвера 
OpenCL не станут работающими
    - исправлена редкая ошибка с несжатыми файлами и AESNI

5.0b - исправлено несколько ошибок, в основном, с RAR 2.0 и очень
большими файлами

5.0-5.0a
     - последняя версия с поддержкой WinXP
     - поддержка NVIDIA Maxwell

5.0 BETA 2
     - в два раза быстрее на Haswell c AVX2. CPU rate при этом =
4.80!
     - подключение CUDA 5.5 неожиданно дало рост на 30-50% на картах
Kepler и Fermi
     - поддержка Intel HD Graphics на OpenCL

5.0 BETA
     - поддержка RAR 5.0 на всех современных архитектурах CPU и
       GPU
     - больше нет разделения на crark и crark-hp, все в одной
       программе

3.45 - новая опция -n для задания номера GPU
     - корректное распознавание процессоров AMD APU
     - немного ускорен XOP-код (Bulldozer/Piledriver)
     - старый код для Pentium III/4 удален

3.43 - улучшены настройки под Kepler
     - индекс GPU и размер сетки GPU вычисляется более аккуратно
     - из-за большого количества ошибок в компиляторах OpenCL
       добавлено самотестирование OpenCL-кода. 

3.42 - улучшена совместимость с RAR 4.0
     - OpenCL-версия под Mac OS

3.41 - опция -d теперь и в OpenCL-версии
     - исправлены существенные ошибки в cRARk-HP

3.4е - поддержка карт NVIDIA Kepler. (Пока без оптимизаций, GTX 680
       оказался очень неудачным для вычисления хэшей)
     - оптимизация под карты AMD GCN (Radeon 7xxx) до 25%
     - еще более точное вычисление индекса CPU и тактов SHA-1
       Отключайте Turbo Boost для получения правильные результатов!

3.4d - исправлен код под Bulldozer (AMD FX). Это пока самый быстрый
       код вообще, CPU rate > 3.0!
     - чуть изменены размеры сетки GPU
     - исправлена серьезная ошибка в OpenCL-коде
     - исправлена ошибка с выполнением AVX-кода на OC, не 
       поддерживающих AVX

3.4c - добавлена совместимость с драйверами Catalyst 11.12

3.4b - повышение скорости не менее 5-7% на Core 2/iX
     - скорость атаки по словарю значительно возросла (20-40%)
     - более точное и детальное вычисление индекса CPU

3.4a - включены инструкции AVX и XOP, около 20% ускорения 
       на Sandy Bridge и (вероятно) на Bulldozer

3.4  - добавлена поддержка OpenCL (бета-версия), работает как
       на картах NVIDIA, так и на AMD.
     - до 15% повышена скорость на картах NVIDIA серии G80
     - значительно повышена скорость на stored-файлах
     - большинство stored-файлов теперь обрабатывается на GPU

3.3d - опция -d теперь работает
     - добавлена совместимость с CUDA 4.0

3.3c - исправлена ошибка "File rarcrypt.dll not found"
     - улучшена поддержка европейских языков, изменен файл
       spanish.def

3.3b - исправлена поддержка Fermi (GTX 4xx). 

3.3  - движок CUDA полностью переписан, теперь он работает быстрее
       до 5%, а также более плавно
     - новая опция -d

3.25
     - подключена CUDA 3.0, что должно исправить некоторые
       проблемы с CUDA
     - небольшие оптимизации на Core 2, Core iX (до 5% быстрее)
     - исправлены некоторые ошибки с RAR 2.0, опция -o

3.2c,d
     - не находился пароль, если набор символов был длиннее 128
3.2b
     - поддержка самораспаковывающихся архивов с зашифрованными
       заголовками
3.2a
     - повышена скорость на 3-5% как в CPU-, так и GPU-коде

3.2
     - скорость CUDA повышена на 50% на картах Geforce 8, 9 серии
       и более чем на 100% на GTX 2xx
     - поддержка CUDA в crark-hp
     - прочие улучшения и исправления в CUDA

3.2 BETA
     - добавлена поддержка технологии CUDA (только перебор по *)
     - опция -c, чтобы не использовать CUDA
3.1c 
     - cущественно повышена скорость на больших файлах
     - убраны незначительные ошибки при работе с архивами с
       зашифрованными заголовками и многотомными архивами 
     - англ. документация в html
     - Mac OS X-версия
     - новый домен crark.net

3.1b - все-таки исправлена ошибка в crark-hp, когда находились
       неправильные пароли
     - скомпилирована Linux-версия
       http://www.password-crackers.com/DOWNLOAD/crark31-linux.tar.gz

3.1a - исправлена серьезная ошибка в crark-hp, когда находились
       неправильные пароли
     - для архивов RAR 3.x введено ограничение на длину пароля
       в 28 символов из-за ошибки реализации SHA в RAR 3.x
     - новая опция -f, позволяющая выбирать криптофункции

3.1  - поддержка архивов с зашифрованными заголовками (отдельная
       программа CRARK-HP
     - устранены некоторые утечки памяти

3.0a - оптимизация под Core 2 (в основном для rar 2.x)

3.0  - увеличена скорость во всех режимах, кроме перебора (по *)
     - корректно поддерживаются архивы, созданные с опцией -mc
     - перенесена из прошлых версий поддержка RAR 2.x, включая
       русские пароли

3.0 BETA  - поддержка RAR 3.0, оптимизация под Pentium III/
       Northwood, Prescott, AMD (особенно под Athlon 64)	

2.4  - хотя взлом паролей RAR 2.x уже не актуален, эта версия 
       выпущена из спортивного интереса. Скорость перебора повышена
       до 25% на 3-символьных паролях и длинее, причем она более не
       зависит от длины пароля. Спасибо Eugene Shelwien за его пару
       потрясающих идей.

2.3b - просто перекомпилировано под P4. Поддержки rar 3.0 пока не
       ожидается.

2.3a - незначительные изменения, чуть-чуть (5%) повышена скорость.

2.3 - 2-х кратная оптимизация в скорости на Pentium Pro/II, распоз-
      навание типа процессора, новые опции -5, -6. Обновлена PCL,
      включая вывод пароля в 16-ричном виде и исправление ошибки
      "not defined .c(1)" - спасибо Jan Polonsky. Дополнена опция -v.

2.2 - Добавлена поддержка "stored"-файлов (-m0). Появился исполня-
      емый файл под Linux (ELF) - быстрее на 5-10%.

2.1a - Исправлена ошибка "5 строки" в PCL 2.0, когда количество
      описаний паролей было больше 4 (Спасибо Dmitry Lisiy!).

2.1 - Подключена библиотека PCL v. 2.0 - соотвественно, появилась
      поддержка разных языков и кодировок, новые  модификаторы  и
      параметры  у них, функции измерения времени и определения
      производительности, максимальная длина пароля увеличена до
      255.

2.0 - Добавлена индикация паролей (примерно 1 на 200000). Исправ-
      лена ошибка с русскими макросами. Исправлена ошибка с фай-
      лами, компрессированными с опцией -mm.

1.99
    - Наконец-то появилась  поддержка RAR 2.0.  Предыдущие версии
      архивов более не поддерживаются.

1.5
    - подключена  библиотека Password  Cracking Library  (PCL) v.
      1.0, позволяющая осуществлять многофункциональную атаку  по
      словарю, атаку перебором с известными символами, восстанов-
      ление неправильно  набранного пароля  и другое.  Исправлена
      ошибка, связанная с маленькими (меньше 10 символов)  файла-
      ми. Дополнена и исправлена документация.

1.02
    - исправлена  ошибка, из-за  которой примерно  с вероятностью
      0.5% не находился  пароль. В качестве  компенсации скорость
      повышена на 5%.

1.01
    - исправлена несущественная ошибка в исходном коде UNRAR 1.01
      (см. what's new в RAR 2.0)

1.00:
     - первая версия, вышедшая в свет.

-----------------------------------------------------------------



                           c R A R k
                 (First & Fastest RAR Cracker)
                            v. 5.5

      (с) Copyright PSW-soft 1995-2001, 2006-19 by P. Semjanov


     ЭТА ВЕРСИЯ ПРОГРАММЫ РАСПРОСТРАНЯЕТСЯ "КАК ЕСТЬ". ВЫ  МОЖЕТЕ
ИСПОЛЬЗОВАТЬ ЕЕ НА СВОЙ СТРАХ И РИСК. НИКАКИЕ ПРЕТЕНЗИИ ПО РАБОТЕ
ПРОГРАММЫ  ПРИНИМАТЬСЯ  НЕ  БУДУТ.  ТАКЖЕ  АВТОР  НЕ  ГАРАНТИРУЕТ
ДАЛЬНЕЙШЕГО СОПРОВОЖДЕНИЯ И ОБНОВЛЕНИЯ ВЕРСИЙ ЭТОЙ ПРОГРАММЫ.
     Данная программа является FREEWARE и может  распространяться
свободно при соблюдении следующих условий: программный код не из-
меняется и  программа  распространяется  в  виде  дистрибутивного
архива. Любое коммерческое использование этой программы запрещено!


                1. Назначение и характеристики.

     Программа cRARk предназначена для определения забытого паро-
ля у RAR-архивов.  Программа  корректно  работает с архивами  RAR
версий 2.x, 3.x, 4.x, 5.x.
     Для работы программе cRARk требуется компьютер с процессором
не ниже Pentium с поддержкой SSE2.
При этом рекомендуется использовать программу на как можно  более
мощном процессоре в монопольном режиме. Программа специально  оп-
тимизирована под  процессоры Core 2/Core i7/AMD Athlon/Bulldozer
и видеокарты NVIDIA GTX 7xxx и выше, AMD/ATI Radeon серии 7xxx
и выше.
     Скорость при полном переборе для RAR 5.х у программы состав-
ляет около  500 паролей/сек  на  современном  мощном  компьютере,
откуда следует, что  реально перебором  можно взломать  пароли не
длиннее 6-ти символов. На видеокартах скорость может достигать
100000 паролей в секунду.
   Скорость работы при атаке по словарю и при  восстановлении не-
правильно  набранного  пароля  составляет  около 100 паролей/сек.
Видеокарты в этих режимах не поддерживаются.


               2. Требования ко входному архиву.

     Для  успешной  работы  программы  для испытуемого RAR-архива
должны выполняться следующие требования:
     - должен быть по крайней мере один зашифрованный файл;
     - пароль должен быть не длиннее 28 символов (RAR 3.x-4.x) 
     - для достижения максимальной  скорости этот файл не  должен
архивироваться с опцией -m0. Если программа выдает предупреждение
по этому поводу, вы можете  просто удалить такой файл из  архива;
     В случае solid-архивов,  этим требованиям должен  удовлетво-
рять первый файл.
     Поэтому, если файлы в архиве шифровались с разными паролями,
то будет найден первый, соответствующий выбранному файлу.
     Программа cRARk должна работать с многотомными и саморазвора-
чивающимися архивами.
     Начиная с версии 3.2, cRARk включает в себя автоматическую
поддержку технологии вычислений на графических картах NVIDIA CUDA,
a с версии 3.4 и графические карты ATI/AMD.
Ограничения в текущей версии работы с GPU:
     1) Поддерживаются только карты NVIDIA c технологией CUDA с
вычислительными возможностями версии 3.0 и карты AMD 5xxx/6xxx
с помощью технологии OpenCL.
     2) Для работы CUDA/OpenCL необходимы самые последние драйвера
     3) Через CUDA/OpenCL осуществляется только переборе паролей,
описание которых содержит символ '*' (повторения); все остальные
пароли проверяются на CPU.
     4) Нестандартные опции компрессии (-mc) не поддерживаются
     5) Архивы RAR 2.x также не поддерживаются

                    3. Работа с программой.

      Для работы с программой в желаемом режиме надо создать файл
описания паролей (см. п. 4). После этого для запуска  используйте
команду:

         CRARK [опции] архив

     Найденный пароль выдается на экран в виде:

truepass - CRC OK

     Далее он повторяется в шестнадцатеричном PDL-виде (см. 4.2.1).
Это удобно, если пароль имеет непечатаемые символы.
     Все остальные сообщения паролями НЕ ЯВЛЯЮТСЯ и предназначены
только для индикации того, что программа не зависла.

     Опциями в этом режиме являются:

    -lXX - установить длину пароля не менее, чем XX (XX = 0..127,
по умолчанию = 1).  Этот параметр  влияет на длину пароля только,
если при его описании использовался символ '*' (cм. п. 4.2.1);
    -gXX - установить длину  пароля не  более XX (XX = 0..127, по
умолчанию = 5);
    -pXXXXX - задать имя  файла описания паролей (по  умолчанию -
"password.def").
    -b  - выполнить измерение производительности (benchmark);
    -v  - отобразить использованные наборы символов для проверки,
насколько правильно вы их задали. Также эта опция генерирует  все
пароли  в  соответствии  с  их  описанием, но вместо тестирования
выводит их на экран, чтобы вы могли проверить правильность их оп-
ределения;
    -с  - отключить поддержку GPU (вычислять на CPU);
    -dXX  - задать задерку для CUDA/OpenCL (XX = 0..5, по
умолчанию - 2). 0 - максимально быстро, 5 - медленно, но с хорошим
откликом видеокарты (плавно);
    -nXX - задавть номер GPU (по умолчанию - 0);
    -fXYZ - использовать криптофукнции с номерами X,Y,Z
(например, -f111). Эта опция только для продвинутых пользователей
для экспериментов со скоростью программы. Некоторую информацию о
имеющихся номерах криптофункций можно получить с помощью опции -b.


     4. Выбор режима работы и множества паролей с помощью
                    файла описания паролей.

    Файл  описания  паролей  (password  definition file) является
главным управляющим файлом. Его трансляция и собственно обработка
является основной задачей библиотеки Password Definition Language
(PDL). Его формат независим от приложения, к которому подключена
PDL, поэтому эта библиотека может быть использована  с любой прог-
раммой, занимающейся подбором паролей.

              4.1. Формат файла описания паролей.

    Файл описания паролей является текстовым файлом в формате
UTF-16 (Windows) или UTF-8 (UNIX, Mac, Windows), состоящем из 
двух частей:  описания словарей  и наборов  символов и описания
паролей, разделяемых строкой из двух символов '##':

    [ <описание словарей и наборов символов> ]
    ##
    <описание паролей>

    Первая часть может отсутствовать, тогда файл должен начинать-
ся с символов '##'.
    При этом в  любом другом месте  символ '#' считается  началом
комментария. Пробелы и табуляции в файле описаний игнорируются  и
могут разделять любые компоненты.
    Для удобства вначале, в отличие от последовательности  описа-
ний в файле, рассмотрим механизм описания паролей, а затем описа-
ние наборов символов.

                     4.2. Описание паролей.

    Это главная часть  файла, ОБЯЗАТЕЛЬНО ПРИСУТСТВУЮЩАЯ  В ЛЮБОМ
ФАЙЛЕ ОПИСАНИЯ ПАРОЛЕЙ (PASSWORD.DEF) ПОСЛЕ СТРОКИ '##',  опреде-
ляет правила  генерации  паролей,  которые и  будут проверятся  в
дальнейшем.  Она состоит  из текстовых  строк, каждая из  которых
задает свое  множество  паролей  и режим работы, т.е.  по  какому
алгоритму они будут  перебираться. Каждая строка является незави-
симой и обрабатывается  отдельно, при этом подсчитывается суммар-
ное число проверенных паролей.
    Основными компонентами описания паролей являются: наборы сим-
волов и слова из словарей.  Они задают один или несколько  симво-
лов, которые будут находится  в пароле на соответствующем  месте.

                    4.2.1. Наборы символов.

     Набор символов (charset)  - это множество  символов, которые
могут  находится  на  текущем  месте  в пароле (но находится, ес-
тественно, всего лишь один из них). К ним могут относиться:

     1) простые одиночные символы (a, b, и т.д.). Означает, что в
данной позиции пароля стоит именно этот символ;
     2) экранированные символы. Специальные символы, если они мо-
гут встретиться в пароле, должны экранироваться. Смысл совпадает
с предыдущими. К ним относятся:

     \$, \., \*, \?, \=       - '$', '.', '*', '?', '='
     \], \[, \{, \}, \(, \)   - соответствующие скобки
     \ (после \ стоит пробел) - пробел
     \\                       - '\'
     \XXXX, где X -
          шестнадцатеричная цифра  - любой символ  через  hex-код
     \0                  - пустой  символ  (отсутствие   символа).
Обычно применяется в объединении с "настоящим" символом (см. при-
меры ниже).
     В принципе, экранироваться могут любые символы, если они  не
являются шестнадцатеричными цифрами.
     3) макросы множества символов. Означают, что в текущей пози-
ции пароля может встретиться любой из символов, входящих во  мно-
жество. Эти множества определяются в первой части файла  описаний
(см. п. 4.3.2), а обозначаются следующими символами:

     $a - маленькие латинские  буквы (если не переопределено,  то
          26 штук);
     $A - большие латинские буквы (если не переопределено, то  26
          штук);
     $! - специальные знаки  (если не переопределено, то  32 шту-
          ки);
     $1 - цифры, (если не переопределено, то 10 штук);
     $i - маленькие буквы национального алфавита (для русского  -
          33 штуки);
     $I - большие буквы национального алфавита (для русского - 33
          штуки);
     $o - другие задаваемые пользователем символы;
     ?  - любой символ (т.е. все символы, входящие в вышеперечис-
          ленные макросы);

ПРИМEЧАНИЕ: макросы $v и  $p (см. 4.3.4) нельзя  использовать для
задания паролей.
     4)  объединения  любых  из  выше перечисленных символов. За-
писывается  с  помощью  квадратных  скобок.  Смысл  совпадает   с
предыдущим. Примеры:

     [$a $A]      - любая латинская буква;
     [abc]        - или a, или b, или c;
     [$1 abcdef]  - шестнадцатеричная цифра;
     [s \0]       - или s, или ничего;
     [$a $A $1 $! $i $I $o] - эквивалентно ?.

     5)  регулярный  символ  повторения  '*'. Означает, что пред-
шествующий ему набор символов нужно  повторить 0 или более раз  в
соответствующих (следующих) позициях пароля. Примеры:

     $a *     - пароль любой длины из маленьких латинских букв;
     [ab] * c - c, ac, bc, aac, abc, bac, bbc, aaac ...
     [$a $A] [$a $A $1] * - "идентификатор" - последовательность
                            букв и цифр, причем первая буква.

     Отметим, что пароль длиной 0 символов имеет определенный фи-
зический смысл, и не всегда эквивалентен отсутствию пароля.
     Длина  повторения  вычисляется двумя способами:
1) автоматически  на основе заданной максимальной и минимальной
длины пароля с помощью опций -l, -g.
Отметим, что эти параметры влияют только на длину пароля, генери-
руемого с помощью символа '*' и не учитываются, если пароль состо-
ит только из слов или статических символов.
2) задается явно в скобках в виде (длина) или (мин. длина, макс.
длина). Например,

    a b *(0,3) c    - сгенерирует 4 пароля: ac, abc, abbc, abbbc.
    a [bc] *(2) d   - abbc, abcd, acbd, accd
    $1 *(2,4)       - все двузначные, трехзначные и четырехзначные
                      числа

     Рекомендуется использовать '*' как можно шире. Это связано с
тем, что  она организует  самый эффективный  перебор. Хотя, вроде
бы, с позиций логики конструкции '? *' и '? ? *' одинаковы,  пер-
вая будет перебираться быстрее.
     Текущее ограничение - '*' может встречаться только один раз.

          4.2.2. Слова из словарей и их модификаторы.

     В отличии от набора символов,  слова задают не один, а  нес-
колько символов  пароля подряд.  В библиотеке  PCL поддерживаются
два словаря: основной (где  чаще всего хранятся обычные  слова) и
пользовательский (где может хранится специфическая информация ти-
па имен собственных, дат и т.п.), хотя разницы между ними никакой
нет.
     Под словарем понимается  текстовый файл в формате UTF-16
(Windows) или UTF-8 (UNIX, Mac, Windows), состоящий  из слов,
разделенных символами конца строки. Могут быть использованы файлы
как DOS- (CR/LF), так и UNIX-формата (LF). Желательно (в том чис-
ле и для скорости перебора), чтобы в словарях слова были в  одном
(нижнем) регистре.
     Таким образом, существуют два макроса:

     $w - слово из основного словаря;
     $u - слово из пользовательского словаря.

     Также под слова  попадают специальные наборы  символов, т.к.
они могут иметь любую длину. Они обозначаются $s(1), $s(2), ... и
определяются спецификой задачи. Для данной программы они не нужны
и не поддерживаются.
     Как  известно,  часто  паролями  бывают  переделанные слова.
Поэтому для определения таких паролей вводится целый набор  моди-
фикаторов (modifiers) слов. К ним относятся:

     .u (upper)    - перевести в верхний регистр;
     .l (lower)    - перевести в нижний регистр;
     .t (truncate) - обрезать до заданной длины;
     .c (convert)  - преобразовать словo;
     .j (joke)     - перевести в верхний регистр некоторые буквы;
     .r (reverse)  - слово наоборот;
     .s (shrink)   - сократить  слово;
     .d (duplicate)- повторить слово 2 раза.

     Модификаторы могут иметь  параметры, записываемые в  круглых
скобках.  Для  модификаторов,  предназначенных  для  работы с от-
дельными  буквами,  можно  задавать  в  качестве  параметра номер
буквы; отсутствие параметра или нулевой параметр означает -  "все
слово". Далее, номера букв  могут задаваться как с  начала слова,
так и с конца - конец слова обозначается символом '-'.
    На сегодняшний день таких модификаторов только 3: .u, .l, .t.
Итак,

     .u  или .u(0)  -  перевести  все  слово  в  верхний регистр
(PASSWORD);
     .u(1),  .u(2)  -  перевести  только  первую  (вторую)  букву
(Password, pAssword);
     .u(-), .u(-1)  -  перевести  последнюю (предпоследнюю) букву
(passworD, passwoRd);
     .t(-1)         - обрезать последнюю букву в слове (passwor).

     Остальные модификаторы  работают только  с целыми  словами и
параметр в них задает способ модификации. На сегодняшний день оп-
ределены следующие параметры к модификаторам:

     .j(0) или .j  - перевести в  верхний регистр нечетные  буквы
(PaSsWoRd);
     .j(1) - перевести в верхний регистр четные буквы (pAsSwOrD):
     .j(2) - перевести в верхний регистр гласные буквы (pAsswOrd);
     .j(3) - перевести  в   верхний  регистр  согласные   буквы
(PaSSWoRD);
     .r(0) или .r - записать слово наоборот (drowssap);
     .s(0) или .s - сократить  слово, убрав гласные, если она  не
первая (password -> psswrd, offset -> offst);
     .d(0) или .d - записать слово два раза (passwordpassword);
     .d(1)       - добавить перевернутое слово (passworddrowssap);
     .c(<номер>) - преобразовать все буквы в слове согласно соот-
ветствующей  строке преобразования (см п. 4.3.3).

     Все модификаторы корректно будут работать как с  латинскими,
так и с национальными буквами, если будут соблюдаться правила за-
дания национальных наборов символов.
     Естественно, что модификатор может быть не единственным (ог-
раничение их числа подряд - 63, которое вряд ли возможно  преодо-
леть). Примеры (пусть $w - password):

     $w.u(1).u(-) - PassworD
     $w.s.t(4)    - pssw
     $w.t(4).s    - pss


                 4.2.3. Генераторы

     Это последний возможный тип компонента паролей, и он генерирует
несколько паролей различной длины из заданных символов в текущей
позиции. Генераторы помечаются символами { и }, за которыми
следует тип генератора, например {abc}.u. Открывающая скобка
указывает позицию начала генератора, а закрывающая - конечную
позицию.

      4.2.3.1. Генератор по умолчанию - пермутационные скобки.

     Это генератор не имеет явного типа и обозначается просто
{abc}.
     Довольно часто встречается ситуация, что вы помните  пароль,
но он почему-то не подходит. Вероятно, вы ошиблись в его  наборе.
Для  восстановления   таких  паролей   в  программе    существует
собственный алгоритм. Считается, что ошибки при наборе могут быть
следующие: переставлены  местами две  соседние буквы  (psasword),
удалена буква  (pasword), вставлена  лишняя (passweord)  или одна
заменена на другую (passwird). Будем называть такие изменения па-
роля пермутациями (permutations).
     Для указания начала и  конца участка пароля, где  могли воз-
никнуть пермутации, применяются пермутационные скобки '{' и  '}'.
После '}' может идти число  пермутаций (по умолчанию - 1),  отде-
ленное точкой. Физический смысл  числа пермутаций - количество
одновременно допущенных ошибок. Примеры:

     {abc} - будет получено 182 (разных) пароля, из них:
             bac, acb       - 2 перестановки;
             bc, ac, bc     - 3 удаления;
             aabc, babc ... - 4 * 26 - 3 вставок;
             bbc, cbc ...   - 3 * 25 замен;
             abc            - само слово;

     {password}.2 или
     {password}(2) - получатся, в частности, такие слова,
                     как psswrod, passwdro и paasswor;

     {$w} - все слова с одной ошибкой из основного словаря.

     Примечания:
     1) Естественно, что некоторые пароли будут получены не  один
раз, причем, чем выше число пермутаций, тем больше будет повторе-
ний. В программе сделаны усилия по сокращению повторений, но  они
чисто эмпирические и проверялись только для числа пермутаций,  не
большего 2. Иначе говоря, для больших чисел нет полной увереннос-
ти, что  какой-либо пароль  не будет  ошибочно выкинут. Фанатикам
комбинаторики  предлагаю   посчитать  точное   число,   например,
{password}.3, и тогда я смогу сравнить его с полученным  програм-
мой.
     2) Для операций вставки и замены надо знать, какое множество
символов вставлять. Если в  части описаний это множество  явно не
задано (см. п. 4.3.4), то в данной программе для наборов символов
это множество формируется автоматически, исходя из того, к  каким
стандартным наборам принадлежат  символы внутри  скобок (т.е. для 
{password} вставляться будет $a, {Password} - [$a $A]).  Для слов
аналогичная операция  проводится  по  первому слову  из  словаря,
при  этом учитываются модификаторы.  Если  это множество задается 
явно, то оно и используется.

      4.2.3.2. Генераторы маленьких и больших букв {}.l, {}.u

    Эти генераторы будут генерировать все возможные комбинации,
переводя заданные символы в верхний или нижний регистр, например:

     {abc}.u	-  abc, Abc, aBc, abC, ABc, AbC, aBC, ABC
     {AbC}.l    -  AbC, abC, Abc, abc
     {$w}.u     - все слова из основного словаря со всеми возможными 
изменениями регистра.

      4.2.3.3. Генераторы преобразований {}.c
  
    Как и вышеприведенный, этот генератор выдает все возможные
комбинации, использую модификатор преобразований (см. 4.3.3).
Например, пусть преобразование .c(0) задает перевод всех букв в
похожие по начертанию. Тогда

     {password}.c(0) - password, pa$sword, pas$word, passw0rd,
                       pa$$word, pa$sw0rd,  pas$w0rd, pa$$w0rd


    Генераторы могут быть вложенными, например, можно использовать
{my{good}password}.u для генерации слова good c ошибкой, после чего
вся конструкция будет побуквенно переводиться в верхний регистр.

   

          4.3. Описание словарей и наборов символов.

    Все описания идут в начале файла описания паролей, до  симво-
лов '##'.

                   4.3.1. Описание словарей.

    Вначале обычно описываются используемые основной и  пользова-
тельский словарь (см. п.  4.2.2). Это необходимо делать  только в
том случае, если при описании паролей будет использоваться  слова
из словарей, т.е. $w или $u.
    Словари задаются следующим образом:

    $w = "<имя_файла_содержащего_словарь>"   # основной словарь
    $u = "c:\\dict\\user.dic"                # дополнительный

    Имя файла необходимо  заключать в кавычки,  а символы пути  -
экранировать.

         4.3.2. Задание используемых наборов символов.

    Далее обычно определяются  используемые наборы символов.  Они
делятся на предопределенные и задаваемые пользователем. Предопре-
деленные состоят из:

     $a - маленьких латинских букв, всего 26 штук;
     $A - больших латинских букв, всего 26 штук;
     $! - специальных знаков {}:"<>?[];\',./~!@#$%^&*()_+`-=\|  -
          32 штуки;
     $1 - цифр, 10 штук.

     Задаваемые пользователем состоят из:

     $i - маленьких букв национального алфавита;
     $I - больших букв национального алфавита;
     $o - дополнительного  набора (например, любые  не набираемые
на клавиатуре символы).

     Определение наборов происходит с помощью следующей конструк-
ции:

     $<набор> = [ <одиночные символы или наборы символов> ]

     Иначе говоря, набор символов записывается с помощью  объеди-
нения символов (см. п. 4.2.1), например:

     $i = [абвгдежзийклмнопрстуфхцчшщъыьэюяс]
     $o = [$! $1 \FF]

ПРИМЕЧАНИЯ:
    1) Определять  разрешается любые  наборы символов,  в т.ч.  и
предопределенные. Например, можно добавить во множество $! допол-
нительные символы, такие как пробел или \FF.
    2) Определение  множеств $i  и $I  автоматически определяет и
функции перевода в  нижний/верхний регистр. Поэтому  важно, чтобы
буквы в этих множествах шли в одном и том же порядке.
    Только после того, как все наборы символов определены,  обра-
зуется полное множество символов '?',  состоящее из [$a $A $1  $!
$i $I $o],  причем именно в  таком порядке -  это важно для  сле-
дующего пункта.

         4.3.3. Задание модификаторов преобразований.

    Далее могут задаваться модификаторы преобразований .c (см. п.
4.2.2), применительно к полному множеству символов ?. Это  дости-
гается с помощью строк вида

    .c(<номер>) = "s=$|S=$|o=0|O=0"

    где преобразования символов разделены '|', а сами преобразования
задаются как пара 'заменяемый символ'='заменающий символ'.
    При использовании данного преобразования слово password будет
преобразовано в pa$$w0rd.
    Номера у модификаторов преобразования могут быть от 0 до 255.

          4.3.4. Задание специальных наборов символов

    К специальным наборам символов относятся:
    $v - множество гласных  букв (во всех алфавитах)  - требуется
только, если используются модификаторы .s и .j.
    $p - множество для вставки и замены при пермутационных  скоб-
ках - требуется только, если почему-то не устраивает автоматичес-
кое получение этого множества (см. п. 4.2.3).
    Они задаются аналогично остальным наборам символов.

	 4.3.5. Задание длины пароля

    Параметры минимальной и максимальной длины пароля влияют
только на описание пароля с регулярным символом повторения '*' и
не влияют на другие описания паролей, включающие только множества
символов, слова или генераторы.
   Чтобы установить диапазон паролей по умолчанию, используйте
 ключевые слова min и max, например:

    min = 1         генерировать пароли длиной от одного символа
    max = 5         генерировать пароли длиной до 5 символов


            4.4. Полезные примеры описания паролей.

     1) Приведу отрывок из документации на программу ZEXPL2L:
     "Допустим,  что  Вы  имеете  архив  с  паролем,  похожим  на
"Heaven!!!", но забыли,  сколько восклицательных знаков  стояло в
конце слова, и какие - строчные/прописные - буквы были  использо-
ваны в слове :  "HeAvEn!!!", "Heaven!" или "HeAven!!!!".  Зато Вы
помните, что пароль был не длиннее, чем 10 символов, и не  короче
7."
     Этот пароль на языке PCL запишется так:
     min=7
     max=10
     ##
     {heaven}.u ! *

(вместо min и max можно использовать опции -l7 -g10).

     Предположим дополнительно, что вы еще и ошиблись при  наборе
основной части пароля. Тогда стоит попробовать следующее:
     {{heaven}}.u ! *

     2) Цитата оттуда же: "Допустим, Вы имеете два варианта стро-
ки пароля: "myprog", "MyProg", "my_prog" и "My_Prog".
     Это запишется как:
     [mM] y [_ \0] [pP] rog

     3) Часто  в качестве  пароля советуют  брать два осмысленных
слова, разделяя их каким-нибудь знаком. Соответствующее описание:
     $w [$1 $!] $w    или
     $w.u(1) [$1 $!] $w.u(1)
Важно отметить,  что оба  $w здесь  не равны  (это разные слова),
всего будет сгенерировано (если 1000 слов в словаре): 1000 * 42
* 1000 = 42 миллиона паролей.

     Если же между словами могло стоять от одного до 3 знаков,
то нужно написать:
    $w [$1 $!] *(1,3) $w

     4) Излюбленные пароли у многих - русское слово, набранное на
клавиатуре на латинском регистре:
     $w.c(0)
при задании соответствующей строки  преобразования .c(0).

     5) Пароль ровно из шести русских букв:
     $i $i $i $i $i $i
Но эффективнее - "$i *" и опции -l6 -g6.

     6) Вы помните, что ваш пароль был  "MyVeryLongGoodPassword",
но он почему-то не подходит. Попробуйте такие комбинации:
     {MyVeryLongGoodPassword}     - 2360 пароля, 10 сек
     {MyVeryLongGoodPassword}.2   - 2785406 паролей, 3 часа

     7)  Вы  знаете,  что  пароль  состоит из осмысленного слова,
внутри которого на какой-то позиции вставлена цифра. Описание:

     $p = [$1]      # задаем множество вставки - цифры
     ##
     {$w}

     8) Атака по слогам. Создайте словарь допустимых слогов ваше-
го языка,  а затем  можно перебрать  все осмысленные  по звучанию
слова следующим образом:

     $u             # все односложные
     $u$u           # двусложные
     $u$u$u         # и т.д.
     $u$u$u$u
     ...

     9) Чтобы распараллелить работу  на 2 компьютера, задайте  им
следующие файлы описаний:
      [abcdefghijklm] $a *         - первому
      [nopqrstuvwxyz] $a *         - второму.
Аналогично поступайте для n компьютеров.

                   5. Возникающие проблемы (FAQ).

     1) Как прервать и продолжить счет дальше?

     Можно безболезненно прерывать программу после вывода  сообще-
ния "Testing XX-chars passwords..." и продолжать затем счет с по-
мощью опции -lXX (здесь оба XX равны).

     2) А как продолжить счет с пароля XXX?

     Пока никак. Это сделано в PCL 3.0, которая используется в
Parallel Password Recovery (http://www.parallelrecovery.com)

     3) Программа считает 10-й день, но ничего не нашла.

     Увы! Тут помочь можно мало чем. Либо пароль слишком  длинен,
либо он неправильно описан. Необходима дополнительная  информация
о пароле.

     4) В архиве файлы с разными паролями. Как найти их все?

     Просто  удалите  с  помощью  RAR  тот  файл,  чей пароль уже
найден.

     5)  Я  проверил  Вашу  программу.  Так  вот, это просто одна
большая ошибка - она даже не определяет двухсимвольный пароль ти-
па "a2".

     RTFM. Файл password.def из дистрибутиве ведет перебор только
по маленьким латинским буквам.  Измените описание пароля на
"[$a $1] *" - и все будет ok.

     6) У меня есть начало одного из заархивированных файлов  или
даже весь файл в открытом виде. Это как-то поможет?

     Нет. По крайней мере, я не смог ничего с этим сделать.  Поп-
робуйте Вы  - алгоритм  шифрования RAR  доступен (см. дистрибутив
WinRAR).

     7) Я хочу попробовать оптимизировать Вашу программу. Можно
получить ее исходные тексты?

     Они Вам  не нужны.  Берите исходники  UnRAR и  оптимизируйте
функцию  SetCryptKeys(). Получится - и Вы  напишете  взломщик RAR
лучше, чем этот.

     8) Есть ли какая-нибудь опция для сохранения протокола работы
программы?

     Вы не работали в UNIX. Используйте
     crark [параметры] > файл_протокола.
Если это не устраивает, используйте утилиту tee.

     9) Как повысить скорость подбора по словарю?

     Отсортируйте слова в словаре по длине слова.

     10) Ваш дистрибутив сам запакован с паролем!!! Это не смешно!

     Раз Вы читаете этот файл. Вы разрешили эту проблему.

     11) Я хочу графический интерфейс, поддержку многих ядер, паузу/
восстановление и т.п.
     
     cRARk - это бесплатная утилита. Все, что Вам нужно, есть у
Parallel Password Recovery (http://www.parallelrecovery.com), лизензировавшая
механизм cRARk и PCL для своих продуктов.

     12) Что надо, чтобы использовать мою графическую карту для перебора
паролей?
     
     a) карта должна быть не ниже, чем NVIDIA GeForce серии 8. При
этом некоторые ранние карты серии 8800 не поддерживаются.
     б) нужны последние драйвера. Лучше брать их отсюда:
http://www.nvidia.com/object/cuda_get.html
     в) в описании паролей должен быть символ '*'
     г) GPU используется только для RAR 3.x, при этом файлы stored и
опции -mc не поддерживаются

     13) У меня возникают ошибки при работе программы на GPU.

     а) поставьте последние драйвера!
     б) не разгоняйте ни GPU, ни CPU
     в) на Windows Vista и 7, если выскакивает сообщение о том, что 
драйвер был установлен, запустите файл driver-timeout.reg из дистрибутива.


                        6. Выводы и перспективы.

     Система шифрования RAR-архивов 3.x-5.x является одной из лучших
с точки зрения скорости перебора из современных приложений, использующих
шифрование. Именно поэтому  у программы  такая малая скорость
перебора.
     На сегодняшний день не известны и крайне маловероятно, что
появятся методы, позволющие вскрывать RAR-архивы быстрее, чем
перебором.

                  8. Как связаться с автором.

     Только по e-mail.
     e-mail: pavel@semjanov.com
     WWW: http://www.semjanov.com

     Основной URL программы:
     http://www.crark.net

     Окончательную и все последующие версии этой программы  можно
взять только  с указанного  WWW-сайта.
     Я буду благодарен  всем, кто ее  будет тестировать и  укажет
мне на явные ошибки, такие как:
     - программа  зависает при  переборе (то,  что она  ничего не
выводит при этом на экран, не является признаком зависания);
     - программа  не находит  такой-то пароль  в таком-то архиве,
хотя множество символов перебора задано верно:
     Так же буду рад любым конструктивным предложениям по улучше-
нию работы программы.


                          9. Спасибо.

     Евгению Рошалу за качественный продукт;
     Eugene Shelwien за его потрясающие идеи по поводу RAR 2.0;
     Phil Frisbie, Jr. за процедуру идентификации CPU;

     всем остальным, кто помогал, советовал и тестировал cRARk.


                    Удачи!

                      P. Semjanov, St. Petersburg.
